每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！

确定递归函数的参数和返回值：
确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

确定终止条件：
写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

确定单层递归的逻辑：
确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

----------------------------------------------------------------------------------------

all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。
元素除了是 0、空、None、False 外都算 True。

-----------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/lilong117194/article/details/78522459

set()函数和frozenset()函数
frozenset() 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。
语法：
class frozenset([iterable])
iterable – 可迭代的对象，比如列表、字典、元组等等
返回新的 frozenset 对象，如果不提供任何参数，默认会生成空集合。

### 区别：
set无序排序且不重复，是可变的，有add（），remove（）等方法。既然是可变的，所以它不存在哈希值。
frozenset是冻结的集合，它是不可变的，存在哈希值，好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法。

------------------------------------------------------------------------------------------------------------------
np.argsort()的用法

numpy.argsort(a, axis=-1, kind=’quicksort’, order=None)

功能: 将矩阵a按照axis排序，并返回排序后的下标
参数: a:输入矩阵， axis:需要排序的维度
返回值: 输出排序后的下标

import numpy as np
x = np.array([1,4,3,-1,6,9])
x.argsort()
# array([3, 0, 1, 2, 4, 5], dtype=int64)

rgsort()是将X中的元素从小到大排序后，提取对应的索引index，然后输出到y
如x[3]=-1最小，x[5]=9最大

取数组x的最小值可以写成:
x[x.argsort()[0]]
或者用argmin()函数  x[x.argmin()]
 
数组x的最大值，写成：
x[x.argsort()[-1]]  # -1代表从后往前反向的索引
或者用argmax()函数  x[x.argmax()]

-------------------------------------------------------------------
numpy.where() 有两种用法：

1. np.where(condition, x, y)
满足条件(condition)，输出x，不满足输出y。
>>> aa = np.arange(10)
>>> np.where(aa,1,-1)
array([-1,  1,  1,  1,  1,  1,  1,  1,  1,  1])  # 0为False，所以第一个输出-1
>>> np.where(aa > 5,1,-1)
array([-1, -1, -1, -1, -1, -1,  1,  1,  1,  1])

2. np.where(condition)
只有条件 (condition)，没有x和y，则输出满足条件 (即非0) 元素的坐标 (等价于numpy.nonzero)。
这里的坐标以tuple的形式给出，通常原数组有多少维，输出的tuple中就包含几个数组，分别对应符合
条件元素的各维坐标。

>>> a = np.array([2,4,6,8,10])
>>> np.where(a > 5)				# 返回索引
(array([2, 3, 4]),)   
>>> a[np.where(a > 5)]  			# 等价于 a[a>5]
array([ 6,  8, 10])

>>> np.where([[0, 1], [1, 0]])
(array([0, 1]), array([1, 0]))

---------------------------------------------------------------

https://blog.csdn.net/LoveCarpenter/article/details/85048822
https://zhuanlan.zhihu.com/p/74427646



https://leetcode-cn.com/problems/happy-number/solution/




