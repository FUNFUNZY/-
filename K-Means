参考链接：https://blog.csdn.net/HUSTLX/article/details/51362267
https://www.cnblogs.com/LittleHann/p/6595148.html
👍 https://blog.csdn.net/weixin_42137700/article/details/90230443


算法原理（思想）：
 KMeans算法是最常用的聚类算法，主要思想是:在给定K值和K个初始类簇中心点的情况下，把每个点(亦即数据记录)分到离其最近的类簇中心点所代表的类簇中，
 所有点分配完毕之后，根据一个类簇内的所有点重新计算该类簇的中心点(取平均值)，然后再迭代的进行分配点和更新类簇中心点的步骤，直至类簇中心点的变化很小，
 或者达到指定的迭代次数。

选出K个初始聚类中心点的方法：
  1) 选择批次距离尽可能远的K个点
  首先随机选择一个点作为第一个初始类簇中心点，然后选择距离该点最远的那个点作为第二个初始类簇中心点，然后再选择距离前两个点的最近距离最大的点
  作为第三个初始类簇的中心点，以此类推，直至选出K个初始类簇中心点。
  该方法经过测试效果很好，用该方法确定初始类簇点之后运行KMeans得到的结果全部都能完美区分五个类簇
  2）canopy算法
  先确定两个距离：L1,L2，且L1>L2。从集合S中随机移出一个点p，计算集合中每个点I到点P的距离，如果此距离小于L1，则把点I加入到点P 的canopy中；
  若果次距离小于L2，则把点I从s中移出，加入到点P的canopy中。重新在s中随机找出一个点P，重复以上步骤。
  
  3）随机取k个点（这种取法效果不好）

K值的确定。
  给定一个合适的类簇指标，比如平均半径或直径，只要我们假设的类簇的数目等于或者高于真实的类簇的数目时，该指标上升会很缓慢，而一旦试图得到少于真实数目
  的类簇时，该指标会急剧上升。
  类簇的直径是指类簇内任意两点之间的最大距离。
  类簇的半径是指类簇内所有点到类簇中心距离的最大值。
